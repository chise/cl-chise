(in-package :chise)

(require 'split-sequence)

(defun ids-parse-terminal (previous in)
  (let ((chr (or previous
		 (read-entity-reference in)
		 (read-char in nil)))
	ucs big5)
    (cond
      ((stringp chr)
       chr)
      (chr
       (setq ucs (encode-char chr '=ucs))
       (or (unless (or (and ucs (<= #x2FF0 ucs)(<= ucs #x2FFF))
		       (member (encode-char chr '=ucs-var-001)
			       '(#x2FF0))
		       (member (encode-char chr '=ucs-itaiji-001)
			       '(#x2FF1 #x2FF9 #x2FF6 #x2FFB))
		       (member (encode-char chr '=ucs-itaiji-002)
			       '(#x2FF1)))
	     (if (and ucs (<= #xE000 ucs)(<= ucs #xF8FF)
		      (setq big5 (encode-char chr '=big5)))
		 (setq chr (decode-char '=big5-cdp big5)))
	     chr)
	   (if (characterp chr)
	       (unread-char chr in)
	       (values nil chr)))
       ))))

(defun ids-parse-op-2 (previous in)
  (let ((chr (or previous
		 (read-entity-reference in)
		 (read-char in nil)))
	ucs)
    (cond
      ((stringp chr)
       (values nil chr)
       )
      (chr
       (setq ucs (encode-char chr '=ucs))
       (cond
	 ((or (and ucs
		   (or (eql ucs #x2FF0)
		       (eql ucs #x2FF1)
		       (and (<= #x2FF4 ucs)(<= ucs #x2FFB))))
	      (member (encode-char chr '=ucs-var-001)
		      '(#x2FF0))
	      (member (encode-char chr '=ucs-itaiji-001)
		      '(#x2FF1 #x2FF9 #x2FF6 #x2FFB))
	      (member (encode-char chr '=ucs-itaiji-002)
		      '(#x2FF1)))
	  chr)
	 ((characterp chr)
	  (unread-char chr in)
	  )
	 (t
	  (values nil chr)
	  ))))))

(defun ids-parse-op-3 (previous in)
  (let ((chr (or previous
		 (read-entity-reference in)
		 (read-char in nil))))
    (cond
      ((member chr '(#\u2FF2 #\u2FF3))
       chr)
      ((characterp chr)
       (unread-char chr in)
       )
      (t
       (values nil chr)
       ))))

(defun ids-parse-element (previous in)
  (let (ret op arg1 arg2 arg3)
    (cond ((multiple-value-bind (parsed rest)
	       (ids-parse-terminal previous in)
	     (setq previous rest
		   ret parsed))
	   (values ret previous)
	   )
	  ((multiple-value-bind (parsed rest)
	       (ids-parse-op-2 previous in)
	     (setq previous rest
		   op parsed))
	   (when (multiple-value-bind (parsed rest)
		     (ids-parse-element previous in)
		   (setq previous rest
			 ret parsed))
	     (setq arg1 ret)
	     (when (multiple-value-bind (parsed rest)
		       (ids-parse-element previous in)
		     (setq previous rest
			   ret parsed))
	       (setq arg2 ret)
	       (values (list (list 'ideographic-structure op arg1 arg2))
		       previous)))
	   )
	  ((multiple-value-bind (parsed rest)
	       (ids-parse-op-3 previous in)
	     (setq previous rest
		   op parsed))
	   (when (multiple-value-bind (parsed rest)
		     (ids-parse-element previous in)
		   (setq previous rest
			 ret parsed))
	     (setq arg1 ret)
	     (when (multiple-value-bind (parsed rest)
		       (ids-parse-element previous in)
		     (setq previous rest
			   ret parsed))
	       (setq arg2 ret)
	       (when (multiple-value-bind (parsed rest)
			 (ids-parse-element previous in)
		       (setq previous rest
			     ret parsed))
		 (setq arg3 ret)
		 (values (list (list 'ideographic-structure op arg1 arg2 arg3))
			 previous))))
	   ))))

(defun ids-parse-string (ids-string)
  "Parse IDS-STRING and return the result."
  (let (parsed rest)
    (when (multiple-value-setq (parsed rest)
	    (with-input-from-string (in ids-string)
	      (ids-parse-element nil in)))
      (unless rest
	(when (consp parsed)
	  parsed)))))

(defun ids-read-file (file &key override prompt)
  (when prompt
    (princ "Loading ")
    (princ file)
    (princ "..."))
  (with-open-file (in file :direction :input)
    (loop (let ((line (read-line in nil))
		fields crep cpos ids opt
		char ret)
	    (if (not line) (return))
	    (setq fields (split-sequence:split-sequence #\tab line))
	    (setq crep (pop fields))
	    (pop fields)
	    (setq ids (pop fields))
	    (setq opt (pop fields))
	    (when (and (eql (search "U+" crep) 0)
		       (setq cpos (parse-integer crep
						 :start 2 :radix 16
						 :junk-allowed t))
		       (setq char (or (decode-char '=ucs cpos)
				      (code-char cpos))))
	      (when (and (or override
			     (null (get-char-attribute
				    char 'ideographic-structure)))
			 (setq ret (ids-parse-string ids))
			 (setq ret (cdr (assoc 'ideographic-structure ret))))
		(put-char-attribute char 'ideographic-structure ret))
	      (when (and opt
			 (or override
			     (null (get-char-attribute
				    char 'ideographic-structure@apparent)))
			 (eql (search "@apparent=" opt) 0)
			 (setq ret (ids-parse-string (subseq opt 10)))
			 (setq ret (cdr (assoc 'ideographic-structure ret))))
		(put-char-attribute
		 char 'ideographic-structure@apparent ret)
		))))
    (when prompt
      (format t "done.~%"))))

(defun ids-index-store-char (product component)
  (let (ret)
    (adjoin-char-attribute component "ideographic-products" product)
    (when (setq ret (get-char-attribute component "ideographic-structure"))
      (ids-index-store-structure product ret))
    (when (setq ret (get-char-attribute component "ideographic-structure@apparent"))
      (ids-index-store-structure product ret))
    (when (setq ret (get-char-attribute component "ideographic-structure@apparent/leftmost"))
      (ids-index-store-structure product ret))
    (when (setq ret (get-char-attribute component "ideographic-structure@apparent/rightmost"))
      (ids-index-store-structure product ret))))

(defun ids-index-store-structure (product structure)
  (setq product (normalize-as-char product))
  (let (ret)
    (dolist (cell (cdr structure))
      (if (char-ref-p cell)
	  (setq cell (getf cell :char)))
      (cond ((or (characterp cell)
		 (concord:object-p cell))
	     (ids-index-store-char product cell))
	    ((setq ret (assoc 'ideographic-structure cell))
	     (ids-index-store-structure product (cdr ret)))
	    ((setq ret (assoc 'ideographic-structure@apparent cell))
	     (ids-index-store-structure product (cdr ret)))
	    ((setq ret (assoc 'ideographic-structure@apparent/leftmost cell))
	     (ids-index-store-structure product (cdr ret)))
	    ((setq ret (assoc 'ideographic-structure@apparent/rightmost cell))
	     (ids-index-store-structure product (cdr ret)))
	    ((and (association-list-p cell)
		  (setq ret (define-char cell)))
	     (ids-index-store-char product ret))
	    ))))

(defun ids-update-index (&optional (s t))
  (format s "Updating index for `ideographic-structure'...")
  (concord:some-in-feature
   (lambda (c v)
     (ids-index-store-structure c v)
     nil)
   "ideographic-structure" :genre 'character)
  (format s "done.~%")
  (format s "Updating index for `ideographic-structure@apparent'...")
  (concord:some-in-feature
   (lambda (c v)
     (ids-index-store-structure c v)
     nil)
   "ideographic-structure@apparent" :genre 'character)
  (format s "done.~%")
  (format s "Updating index for `ideographic-structure@apparent/leftmost'...")
  (concord:some-in-feature
   (lambda (c v)
     (ids-index-store-structure c v)
     nil)
   "ideographic-structure@apparent/leftmost" :genre 'character)
  (format s "done.~%")
  (format s "Updating index for `ideographic-structure@apparent/rightmost'...")
  (concord:some-in-feature
   (lambda (c v)
     (ids-index-store-structure c v)
     nil)
   "ideographic-structure@apparent/rightmost" :genre 'character)
  (format s "done.~%")
  (let (products ucs)
    (concord:some-in-feature
     (lambda (c v)
       (setq products (get-char-attribute c 'ideographic-products))
       (dolist (comp (remove c (char-ucs-chars c)))
	 (dolist (p_c (get-char-attribute comp 'ideographic-products))
	   (unless (encode-char p_c '=ucs)
	     (if (setq ucs (char-ucs p_c))
		 (setq p_c (decode-char '=ucs ucs))))
	   (setq products (adjoin p_c products))))
       (put-char-attribute c 'ideographic-products products)
       nil)
     '=>iwds-1)
    (concord:some-in-feature
     (lambda (c v)
       (setq products (get-char-attribute c 'ideographic-products))
       (dolist (comp (remove c (char-ucs-chars c)))
	 (dolist (p_c (get-char-attribute comp 'ideographic-products))
	   (unless (encode-char p_c '=ucs)
	     (if (setq ucs (char-ucs p_c))
		 (setq p_c (decode-char '=ucs ucs))))
	   (setq products (adjoin p_c products))))
       (put-char-attribute c 'ideographic-products products)
       nil)
     '=>ucs@iwds-1)
    (concord:some-in-feature
     (lambda (c v)
       (setq products (get-char-attribute c 'ideographic-products))
       (dolist (comp (delq c (char-ucs-chars c)))
	 (put-char-attribute
	  comp 'ideographic-products
	  (union products
		 (get-char-attribute comp 'ideographic-products))))
       )
     '=>iwds-1)
    (concord:some-in-feature
     (lambda (c v)
       (setq products (get-char-attribute c 'ideographic-products))
       (dolist (comp (delq c (char-ucs-chars c)))
	 (put-char-attribute
	  comp 'ideographic-products
	  (union products
		 (get-char-attribute comp 'ideographic-products))))
       )
     '=>ucs@iwds-1)
    )
  )

(defun ideograph-find-products (components &optional ignored-chars)
  (if (stringp components)
      (setq components (concatenate 'list components)))
  (let (dest products)
    (setq dest (get-char-attribute (car components) "ideographic-products"))
    (loop
      (unless (and dest
		   (setq components (cdr components)))
	(return))
      (setq products (get-char-attribute (car components) "ideographic-products"))
      (setq dest (intersection dest products)))
    dest))

(defun ideographic-structure-merge-components-alist (ca1 ca2)
  (let ((dest-alist ca1)
	ret)
    (dolist (cell ca2)
      (if (setq ret (assoc (car cell) dest-alist))
	  (setf (cdr ret) (+ (cdr ret)(cdr cell)))
	  (setq dest-alist (cons cell dest-alist))))
    dest-alist))

(defun ideographic-structure-to-components-alist (structure)
  (apply #'ideographic-structure-to-components-alist* structure))

(defun ideographic-structure-to-components-alist* (operator component1 component2
							    &optional component3
							    &rest opts)
  (let (dest-alist ret)
    (setq dest-alist
	  (cond ((or (characterp component1)
		     (concord:object-p component1))
		 (unless (encode-char component1 "ascii")
		   (list (cons component1 1)))
		 )
		((setq ret (assoc 'ideographic-structure component1))
		 (ideographic-structure-to-components-alist (cdr ret))
		 )
		((setq ret (find-char component1))
		 (list (cons ret 1))
		 )))
    (setq dest-alist
	  (ideographic-structure-merge-components-alist
	   dest-alist
	   (cond ((or (characterp component2)
		      (concord:object-p component2))
		  (unless (encode-char component2 "ascii")
		    (list (cons component2 1)))
		  )
		 ((setq ret (assoc 'ideographic-structure component2))
		  (ideographic-structure-to-components-alist (cdr ret))
		  )
		 ((setq ret (find-char component2))
		  (list (cons ret 1))
		  ))))
    (if (member operator '(#\u2FF2 #\u2FF3))
	(ideographic-structure-merge-components-alist
	 dest-alist
	 (cond ((or (characterp component3)
		    (concord:object-p component3))
		(unless (encode-char component3 "ascii")
		  (list (cons component3 1)))
		)
	       ((setq ret (assoc 'ideographic-structure component3))
		(ideographic-structure-to-components-alist (cdr ret))
		)
	       ((setq ret (find-char component3))
		(list (cons ret 1))
		)))
      dest-alist)))

(defun ids-find-merge-variables (ve1 ve2)
  (cond ((eq ve1 t)
	 ve2)
	((eq ve2 t)
	 ve1)
	(t
	 (let ((dest-alist ve1)
	       (rest ve2)
	       cell ret)
	   (while (and rest
		       (setq cell (car rest))
		       (if (setq ret (assoc (car cell) ve1))
			   (eq (cdr ret)(cdr cell))
			 (setq dest-alist (cons cell dest-alist))))
	     (setq rest (cdr rest)))
	   (if rest
	       nil
	     dest-alist)))))

(defun ideographic-structure-equal (structure1 structure2)
  (let (dest-alist ret)
    (and (setq dest-alist (ideographic-structure-character=
			   (car structure1)(car structure2)))
	 (setq ret (ideographic-structure-character=
		    (nth 1 structure1)(nth 1 structure2)))
	 (setq dest-alist (ids-find-merge-variables dest-alist ret))
	 (setq ret (ideographic-structure-character=
		    (nth 2 structure1)(nth 2 structure2)))
	 (setq dest-alist (ids-find-merge-variables dest-alist ret))
	 (if (member (car structure1) '(#\u2FF2 #\u2FF3))
	     (and (setq ret (ideographic-structure-character=
			     (nth 3 structure1)(nth 3 structure2)))
		  (setq dest-alist (ids-find-merge-variables dest-alist ret)))
	   dest-alist))))

(defun ideographic-structure-character= (c1 c2)
  (let (ret ret2)
    (cond ((or (characterp c1)
	       (concord:object-p c1))
	   (cond ((encode-char c1 "ascii")
		  (list (cons c1 c2))
		  )
		 ((or (characterp c2)
		      (concord:object-p c2))
		  (if (encode-char c2 "ascii")
		      (list (cons c2 c1))
		    (eq c1 c2))
		  )
		 ((setq ret2 (find-char c2))
		  (eq c1 ret2)
		  )
		 ((setq ret2 (assoc 'ideographic-structure c2))
		  (and (setq ret (get-char-attribute c1 'ideographic-structure))
		       (ideographic-structure-equal ret (cdr ret2)))
		  ))
	   )
	  ((setq ret (assoc 'ideographic-structure c1))
	   (cond ((or (characterp c2)
		      (concord:object-p c2))
		  (if (encode-char c2 "ascii")
		      (list (cons c2 c1))
		    (and (setq ret2 (get-char-attribute c2 'ideographic-structure))
			 (ideographic-structure-equal (cdr ret) ret2)))
		  )
		 ((setq ret2 (find-char c2))
		  (and (setq ret2 (get-char-attribute ret2 'ideographic-structure))
		       (ideographic-structure-equal (cdr ret) ret2))
		  )
		 ((setq ret2 (assoc 'ideographic-structure c2))
		  (ideographic-structure-equal (cdr ret)(cdr ret2))
		  ))
	   )
	  ((setq ret (find-char c1))
	   (cond ((or (characterp c2)
		      (concord:object-p c2))
		  (if (encode-char c2 "ascii")
		      (list (cons c2 c1))
		    (eq ret c2))
		  )
		 ((setq ret2 (find-char c2))
		  (eq ret ret2)
		  )
		 ((setq ret2 (assoc 'ideographic-structure c2))
		  (and (setq ret (get-char-attribute ret 'ideographic-structure))
		       (ideographic-structure-equal ret (cdr ret2))
		       )))))))

;;;###autoload
(defun ideographic-structure-find-chars (structure)
  (let ((comp-alist (ideographic-structure-to-components-alist structure))
	ret pl str)
    (dolist (pc (caar
		 (sort (mapcar (lambda (cell)
				 (if (setq ret (get-char-attribute
						(car cell) 'ideographic-products))
				     (cons ret (length ret))
				   (cons nil 0)))
			       comp-alist)
		       (lambda (a b)
			 (< (cdr a)(cdr b))))))
      (when (or (and (setq str
			   (get-char-attribute pc 'ideographic-structure))
		     (ideographic-structure-equal str structure))
		(and (setq str
			   (get-char-attribute pc 'ideographic-structure@apparent))
		     (ideographic-structure-equal str structure))
		(and (setq str
			   (get-char-attribute pc 'ideographic-structure@apparent/leftmost))
		     (ideographic-structure-equal str structure))
		(and (setq str
			   (get-char-attribute pc 'ideographic-structure@apparent/rightmost))
		     (ideographic-structure-equal str structure)))
	(setq pl (cons pc pl))
	))
    pl))
